<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Kapitel 9. Unix-Dienste</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 3.1.5" /><meta name="package" content="Debian-debian-handbook-7-de-DE-1.0-1" /><meta name="keywords" content="Systemstart, Initialisierungsskripten, SSH, Telnet, Rechte, Berechtigungen, Überwachung, Inetd, Cron, Datensicherung, Wechsel im laufenden Betrieb, PCMCIA, APM, ACPI" /><link rel="home" href="index.html" title="Das Debian Administrationshandbuch" /><link rel="up" href="index.html" title="Das Debian Administrationshandbuch" /><link rel="prev" href="sect.kernel-installation.html" title="8.11. Einen Kernel installieren" /><link rel="next" href="sect.remote-login.html" title="9.2. Anmelden aus der Ferne" /></head><body><p id="title"><a class="left" href="http://www.debian.org"><img alt="Product Site" src="Common_Content/images//image_left.png" /></a><a class="right" href="http://debian-handbook.info"><img alt="Documentation Site" src="Common_Content/images//image_right.png" /></a></p><ul class="docnav top"><li class="previous"><a accesskey="p" href="sect.kernel-installation.html"><strong>Zurück</strong></a></li><li class="home">Das Debian Administrationshandbuch</li><li class="next"><a accesskey="n" href="sect.remote-login.html"><strong>Weiter</strong></a></li></ul><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a xmlns="" id="unix-services"></a>Kapitel 9. Unix-Dienste</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="unix-services.html#sect.system-boot">9.1. Systemstart</a></span></dt><dt><span class="section"><a href="sect.remote-login.html">9.2. Anmelden aus der Ferne</a></span></dt><dd><dl><dt><span class="section"><a href="sect.remote-login.html#sect.ssh">9.2.1. Sicheres Anmelden aus der Ferne: SSH</a></span></dt><dt><span class="section"><a href="sect.remote-login.html#sect.remote-desktops">9.2.2. Entfernte grafische Arbeitsflächen benutzen</a></span></dt></dl></dd><dt><span class="section"><a href="sect.rights-management.html">9.3. Berechtigungen verwalten</a></span></dt><dt><span class="section"><a href="sect.administration-interfaces.html">9.4. Administrations-Schnittstellen</a></span></dt><dd><dl><dt><span class="section"><a href="sect.administration-interfaces.html#sect.webmin">9.4.1. Administrieren über eine Webschnittstelle: <code class="command">webmin</code></a></span></dt><dt><span class="section"><a href="sect.administration-interfaces.html#sect.debconf">9.4.2. Pakete konfigurieren: <code class="command">debconf</code></a></span></dt></dl></dd><dt><span class="section"><a href="sect.syslog.html">9.5. <code class="command">syslog</code> Systemereignisse</a></span></dt><dd><dl><dt><span class="section"><a href="sect.syslog.html#sect.syslog-principe">9.5.1. Prinzip und Mechanismus</a></span></dt><dt><span class="section"><a href="sect.syslog.html#sect.syslog-config">9.5.2. Die Konfigurationsdatei</a></span></dt></dl></dd><dt><span class="section"><a href="sect.inetd.html">9.6. Der Superserver <code class="command">inetd</code></a></span></dt><dt><span class="section"><a href="sect.task-scheduling-cron-atd.html">9.7. Aufgaben mit <code class="command">cron</code> und <code class="command">atd</code> zeitlich festlegen</a></span></dt><dd><dl><dt><span class="section"><a href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Aufbau der Datei <code class="filename">crontab</code></a></span></dt><dt><span class="section"><a href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Verwendung des Befehls <code class="command">at</code></a></span></dt></dl></dd><dt><span class="section"><a href="sect.asynchronous-task-scheduling-anacron.html">9.8. Asynchrone Aufgaben planen: <code class="command">anacron</code></a></span></dt><dt><span class="section"><a href="sect.quotas.html">9.9. Quoten</a></span></dt><dt><span class="section"><a href="sect.backup.html">9.10. Datensicherung</a></span></dt><dd><dl><dt><span class="section"><a href="sect.backup.html#idm139785310185424">9.10.1. Datensicherung mit <code class="command">rsync</code></a></span></dt><dt><span class="section"><a href="sect.backup.html#idm139785310140048">9.10.2. Rechner ohne Sicherheitskopien wiederherstellen</a></span></dt></dl></dd><dt><span class="section"><a href="sect.hotplug.html">9.11. Wechsel im laufenden Betrieb: <span class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span class="section"><a href="sect.hotplug.html#idm139785310119488">9.11.1. Einführung</a></span></dt><dt><span class="section"><a href="sect.hotplug.html#idm139785310109008">9.11.2. Das Namensproblem</a></span></dt><dt><span class="section"><a href="sect.hotplug.html#idm139785310093712">9.11.3. Wie <span class="emphasis"><em>udev</em></span> funktioniert</a></span></dt><dt><span class="section"><a href="sect.hotplug.html#idm139785310032992">9.11.4. Ein konkretes Beispiel</a></span></dt></dl></dd><dt><span class="section"><a href="sect.power-management.html">9.12. Modernes Energiemanagement: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div class="highlights"><div class="para">
		Dieses Kapitel behandelt eine Reihe grundlegender Dienste, die vielen Unix-Systemen gemein sind. Alle Administratoren sollten mit ihnen vertraut sein.
	</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns="" id="sect.system-boot"></a>9.1. Systemstart</h2></div></div></div><a id="idm139785313947056" class="indexterm"></a><div class="para">
			Beim Hochfahren des Rechners zeigen die zahlreichen Meldungen, die auf der Konsole vorüberrollen, viele selbsttätig ausgeführte Initialisierungen und Konfigurierungen an. Manchmal möchten Sie vielleicht den Ablauf dieser Phase etwas verändern, weshalb Sie sie gut verstehen müssen. Das ist der Zweck dieses Abschnitts.
		</div><div class="para">
			Zunächst übernimmt das BIOS die Kontrolle über den Rechner, erkennt die Festplatten, lädt den <span class="emphasis"><em>Master Boot Record</em></span> und führt den Boot-Loader aus. Der Boot-Loader übernimmt, ermittelt den Kernel auf der Festplatte, lädt ihn und führt ihn aus. Der Kernel wird dann initialisiert und beginnt damit, nach der Partition, die das Wurzel-Dateisystem enthält, zu suchen und sie einzuhängen, und führt schließlich das erste Programm aus – <code class="command">init</code>. In vielen Fällen befinden sich diese „Wurzel-Partition“ und der <code class="command">init</code>-Befehl jedoch in einem virtuellen Dateisystem, das nur im Arbeitsspeicher existiert (daher sein Name „initramfs“, früher „initrd“ genannt für „initialization RAM disk“). Dieses Dateisystem wird vom Boot-Loader in den Speicher geladen, häufig aus einer Datei auf einer Festplatte oder aus dem Netzwerk. Es enthält das absolute Minimum dessen, was vom Kernel benötigt wird, um das „wirkliche“ Wurzel-Dateisystem zu laden: dies können Treiber-Module für die Festplatte oder andere Geräte sein, ohne die das System nicht hochfahren kann, oder häufiger Initialisierungsskripten und -module zum Aufbau von RAID-Arrays, zum Öffnen verschlüsselter Partitionen, zur Aktivierung von LVM-Volumes usw. Sobald die Wurzel-Partition eingehängt ist, übergibt initramfs die Kontrolle an das wirkliche init, und der Rechner kehrt zum Standard-Startprozess zurück.
		</div><div class="para">
			Das "tatsächliche init" wird zur Zeit von <span class="pkg pkg">sysv-rc</span> (“System V”) bereitgestellt und dieser Abschnitt beschreibt das Init-System.
		</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>SONDERFALL</em></span> Aus dem Netzwerk hochfahren</strong></p></div></div></div><div class="para">
			Bei einigen Konfigurationen kann das BIOS so eingestellt sein, dass es nicht den MBR ausführt, sondern seine Entsprechung im Netzwerk sucht, wodurch es möglich wird, Rechner ohne Festplatte zu bauen oder solche, die bei jedem Neustart vollständig neu installiert werden. Diese Option steht aber nicht auf jeder Hardware zur Verfügung und erfordert im Allgemeinen eine passende Kombination aus BIOS und Netzwerkkarte.
		</div><div class="para">
			Das Hochfahren aus dem Netzwerk kann dazu verwendet werden, den <code class="command">Debian-Installer</code> oder FAI zu starten (siehe <a class="xref" href="installation.html#sect.installation-methods">Abschnitt 4.1, „Installationsmethoden“</a>).
		</div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Der Prozess, eine Programminstanz</strong></p></div></div></div><a id="idm139785327048048" class="indexterm"></a><div class="para">
			Ein Prozess ist die Darstellung eines laufenden Programms im Speicher. Er umfasst alle Informationen, die für die ordnungsgemäße Ausführung der Software erforderlich sind (den Code selbst, aber auch die Daten, die er im Speicher hält, die Liste der Dateien, die er geöffnet hat, die Netzwerkverbindungen, die er eingerichtet hat usw.). Ein einzelnes Programm kann in mehreren Prozessen instanziiert sein, die nicht notwendigerweise unter verschiedenen Benutzerkennungen laufen.
		</div></div><div class="para">
			Init führt mehrere Prozesse gemäß den Anweisungen der Datei <code class="filename">/etc/inittab</code> aus. Das erste Programm, das ausgeführt wird (und dem Schritt <span class="emphasis"><em>sysinit</em></span> entspricht), ist <code class="command">/etc/init.d/rcS</code>, ein Skript, das alle Programme im Verzeichnis <code class="filename">/etc/rcS.d/</code> ausführt. <a id="idm139785317022064" class="indexterm"></a> <a id="idm139785317021264" class="indexterm"></a> <a id="idm139785317020464" class="indexterm"></a> <a id="idm139785317019664" class="indexterm"></a>
		</div><div class="para">
			Unter diesen befinden sich nacheinander Programme, die zuständig sind für:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					das Konfigurieren der Konsolentastatur;
				</div></li><li class="listitem"><div class="para">
					das Laden von Treibern: die meisten Kernelmodule werden beim Erkennen der Hardware vom Kernel selbst geladen; zusätzliche Treiber werden selbsttätig geladen, wenn die entsprechenden Module in der Datei <code class="filename">/etc/modules</code> aufgeführt sind;
				</div></li><li class="listitem"><div class="para">
					die Überprüfung des Dateisystems auf Integrität;
				</div></li><li class="listitem"><div class="para">
					das Einhängen lokaler Partitionen;
				</div></li><li class="listitem"><div class="para">
					das Konfigurieren des Netzwerks;
				</div></li><li class="listitem"><div class="para">
					das Einhängen von Netzwerkdateisystemen (NFS).
				</div></li></ul></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>SICHERHEIT</em></span> Eine Shell als <code class="command">init</code> verwenden, um Administratorrechte zu erlangen</strong></p></div></div></div><div class="para">
			Vereinbarungsgemäß ist der erste Prozess, der gestartet wird, das Programm <code class="command">init</code>. Man kann dem Kernel jedoch eine <code class="literal">init</code>-Option übergeben, die ein anderes Programm angibt.
		</div><a id="idm139785324319840" class="indexterm"></a><div class="para">
			Jeder mit Zugang zum Rechner kann die <span class="keycap"><strong>Reset</strong></span>-Taste drücken und ihn so neu starten. Dann ist es an der Eingabeaufforderung des Boot-Loaders möglich, dem Kernel die Option <code class="literal">init=/bin/sh</code> zu übergeben und so ohne Kenntnis des Administrator-Passworts Root-Rechte zu erlangen.
		</div><div class="para">
			Um dieses zu verhindern, kann man den Boot-Loader selbst mit einem Passwort absichern. Man könnte auch den Zugang zum BIOS schützen (ein Passwort-Schutzmechanismus ist fast immer verfügbar), ohne den ein böswilliger Eindringling jedoch den Rechner immer noch mit einem Wechseldatenträger, der sein eigenes Linux-System enthält, hochfahren könnte, und das er dann dazu benutzen könnte, um auf Daten auf den Festplatten des Rechners zuzugreifen.
		</div><div class="para">
			Schließlich sollten Sie beachten, dass die meisten BIOS ein voreingestelltes Passwort haben. Ursprünglich dazu gedacht, denen zu helfen, die ihr Passwort vergessen haben, sind diese Passwörter inzwischen öffentlich bekannt und im Internet verfügbar (sehen Sie selbst, indem sie in einer Suchmaschine „Standard-Passwörter“ eingeben). Alle diese Sicherheitsmaßnahmen können daher zwar den unbefugten Zugriff auf den Rechner erschweren, ihn aber nicht vollständig verhindern. Es gibt keinen zuverlässigen Weg, einen Computer zu schützen, falls der Angreifer physisch auf ihn zugreifen kann; er könnte die Festplatten ausbauen, um sie an einen Rechner unter seiner Kontrolle anzuschließen oder das ganze Gerät stehlen oder den BIOS-Speicher löschen, um so das Passwort zurückzusetzen…
		</div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Kernelmodule und -optionen</strong></p></div></div></div><a id="idm139785324313808" class="indexterm"></a><div class="para">
			Kernelmodule verfügen ebenfalls über Optionen, die konfiguriert werden können, indem man Dateien im Verzeichnis <code class="filename">/etc/modprobe.d/</code> erstellt. Diese Optionen werden durch Anweisungen wie die folgende festgelegt: <code class="literal">options <em class="replaceable"><code>modulname</code></em> <em class="replaceable"><code>optionsname</code></em>=<em class="replaceable"><code>optionswert</code></em></code>. Falls erforderlich, können mehrere Optionen in einer einzelnen Anweisung gesetzt werden.
		</div><div class="para">
			Die Konfigurationsdateien sind für das Programm <code class="command">modprobe</code> bestimmt, das ein Kernelmodul mit seinen Abhängigkeiten lädt (Module können auch andere Module aufrufen). Dieses Programm wird durch das Paket <span class="pkg pkg">kmod</span> bereitgestellt.
		</div><a id="idm139785324307888" class="indexterm"></a><a id="idm139785324306768" class="indexterm"></a></div><div class="para">
			Nach dieser Phase übernimmt <code class="command">init</code> und startet die im Standard-Runlevel (der normalerweise Runlevel 2 ist) aktivierten Programme. Es führt <code class="command">/etc/init.d/rc 2</code> aus, ein Skript, das alle Dienste startet, die in <code class="filename">/etc/rc2.d/</code> aufgeführt sind und mit dem Buchstaben „S“ beginnen. Die anschließenden zweistelligen Zahlen wurden früher dazu benutzt, die Reihenfolge festzulegen, in der die Dienste gestartet werden mussten, aber heute verwendet das Standard-Bootsystem <code class="command">insserv</code>, das ausgehend von den Abhängigkeiten der Skripten alles selbsttätig zeitlich festlegt. Jedes Boot-Skript legt die Bedingungen fest, die gelten müssen, damit ein Dienst gestartet oder beendet wird (ob er zum Beispiel vor oder nach einem anderen Dienst gestartet werden muss); <code class="command">init</code> startet sie dann in der Reihenfolge, die diese Bedingungen erfüllt. Die feststehende Nummerierung der Skripten wird daher nicht mehr berücksichtigt (sie müssen trotzdem weiterhin einen Namen haben, der mit „S“ beginnt gefolgt von zwei Zahlen und dem Namen des Skripts, das für die Abhängigkeiten verwendet wird). Im Allgemeinen werden grundlegende Dienste (wie das Protokollieren mit <code class="command">rsyslog</code> oder die Portzuweisung mit <code class="command">portmap</code>) als erste gestartet, gefolgt von Standarddiensten und der grafischen Schnittstelle (<code class="command">gdm</code>).
		</div><div class="para">
			Dieses Bootsystem auf der Grundlage von Abhängigkeiten ermöglicht es, die Neu-Nummerierung zu automatisieren, die recht mühsam wäre, wenn sie von Hand erledigt werden müsste, und es begrenzt das Risiko menschlichen Versagens, da die Festlegung der zeitlichen Abfolge in Übereinstimmung mit den angegebenen Parametern erfolgt. Ein weiterer Vorteil besteht darin, dass voneinander unabhängige Dienste zeitgleich gestartet werden können, was den Prozess des Hochfahrens beschleunigt.
		</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ALTERNATIVE</em></span> Andere Bootsysteme</strong></p></div></div></div><div class="para">
			Dieses Buch beschreibt das von Debian standardmäßig verwendete Bootsystem (wie es vom Paket <span class="pkg pkg">sysvinit</span> umgesetzt wird), das vom Unix-System <span class="emphasis"><em>System V</em></span> abgeleitet und übernommen ist; es gibt jedoch auch andere. <span class="distribution distribution">Jessie</span> wird sehr wahrscheinlich mit einem anderen Startsystem ausgeliefert werden, da das bestehende nicht mehr zu der Dynamik im Rechnerwesen passt.
		</div><div class="para">
			<span class="pkg pkg">file-rc</span> ist ein Bootsystem mit einem sehr einfachen Ablauf. Es behält das Prinzip der Runlevel bei, ersetzt jedoch die Verzeichnisse und symbolischen Verknüpfungen durch eine Konfigurationsdatei, die für <code class="command">init</code> die zu startenden Prozesse und ihre Startreihenfolge angibt.
		</div><div class="para">
			Der Befehl <code class="command">upstart</code> ist auf Debian immer noch nicht vollständig ausgetestet. Es arbeitet ereignisbasiert: Initialisierungsskripten werden nicht mehr der Reihe nach ausgeführt, sondern als Reaktion auf Ereignisse, wie zum Beispiel die Ausführung eines anderen Skripts, von dem sie abhängen. Dieses von Ubuntu eingeführte System ist in Debian <span class="distribution distribution">Wheezy</span> vorhanden, aber nicht als Standard eingestellt. Es ist ein Nachfolger für <span class="pkg pkg">sysvinit</span>, und eine der von <code class="command">upstart</code> ausgeführten Aufgaben besteht darin, die für traditionelle Systeme geschriebenen Skripten zu starten, insbesondere die aus dem Paket <span class="pkg pkg">sysv-rc</span>.
		</div><div class="para">
			Eine weitere neue Option, <code class="command">systemd</code>, gewinnt immer mehr Zuspruch. Seine Vorgehensweise ist derjenigen der vorhergehenden Systeme entgegengesetzt. Statt vorsorglich alle Dienste zu starten und dabei die Frage der zeitlichen Reihenfolge lösen zu müssen, startet <code class="command">systemd</code> Dienste nach Bedarf, in etwa entsprechend dem Prinzip von <code class="command">inetd</code>. Dies bedeutet jedoch, dass das Bootsystem wissen muss, wie Dienste bereitgestellt werden (dies könnte durch einen Socket, ein Dateisystem oder etwas anderes erfolgen), und folglich jeweils kleine Anpassungen dieser Dienste erforderlich macht. Rückwärtskompatibilität zu den init-Skripten von System V ist gegeben.
		</div><div class="para">
			Es gibt weitere Systeme und Betriebsarten wie zum Beispiel <code class="command">runit</code>, <code class="command">minit</code> und <code class="command">initng</code>, die jedoch recht spezialisiert und nicht weit verbreitet sind.
		</div></div><a id="idm139785313238688" class="indexterm"></a><a id="idm139785313237728" class="indexterm"></a><div class="para">
			<code class="command">init</code> unterscheidet zwischen verschiedenen Runleveln, so dass es mit dem Befehl <code class="command">telinit <em class="replaceable"><code>neuer-level</code></em></code> von einem zum anderen umschalten kann. <code class="command">init</code> führt bei einem neuen Runlevel unmittelbar ein weiteres Mal <code class="command">/etc/init.d/rc</code> aus. Dieses Skript startet dann die fehlenden Diensten und beendet die nicht mehr benötigten. Hierzu bezieht es sich auf den Inhalt der Datei <code class="filename">/etc/rc<em class="replaceable"><code>X</code></em>.d</code> (wobei <em class="replaceable"><code>X</code></em> den neuen Runlevel bezeichnet). Skripten, deren Namen mit „S“ beginnen (wie in „Start“), verweisen auf zu startende Dienste, solche mit „K“ (wie in „Kill“) auf zu beendende. Das Skript startet keine Dienste, die im vorherigen Runlevel bereits aktiv waren.
		</div><div class="para">
			Standardmäßig verwendet Debian vier verschiedene Runlevel:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Level 0 wird nur vorübergehend beim Herunterfahren des Rechners benutzt. Daher enthält er nur zahlreiche „K“-Skripten.
				</div></li><li class="listitem"><div class="para">
					Level 1, auch Single-User Modus genannt, entspricht dem System in rudimentärem Zustand. Er umfasst einzig grundlegende Dienste und ist hauptsächlich für den Systemunterhalt gedacht, bei dem Interaktionen mit normalen Benutzern nicht erwünscht sind.
				</div></li><li class="listitem"><div class="para">
					Level 2 ist der Level für den Normalbetrieb, der Netzwerkdienste, eine grafische Schnittstelle, Benutzeranmeldungen usw. umfasst.
				</div></li><li class="listitem"><div class="para">
					Level 6 gleicht Level 0, nur dass er während des Herunterfahrens vor einem Neustart verwendet wird.
				</div></li></ul></div><div class="para">
			Es gibt weitere Level, insbesondere 3 bis 5. Standardmäßig sind sie so konfiguriert, dass sie sich wie Level 2 verhalten. Jedoch kann der Administrator sie verändern (indem er in den entsprechenden Verzeichnissen unter <code class="filename">/etc/rc<em class="replaceable"><code>X</code></em>.d</code> Skripten hinzufügt oder löscht), um sie so besonderen Bedürfnissen anzupassen.
		</div><div class="figure"><a xmlns="" id="figure.boot-process"></a><div class="figure-contents"><div class="mediaobject"><img src="images/startup.png" alt="Boot-Sequenz eines Rechners, auf dem Linux läuft" /></div></div><p class="title"><strong>Abbildung 9.1. Boot-Sequenz eines Rechners, auf dem Linux läuft</strong></p></div><br class="figure-break" /><a id="idm139785325048464" class="indexterm"></a><div class="para">
			Alle in den verschiedenen Verzeichnissen unter <code class="filename">/etc/rc<em class="replaceable"><code>X</code></em>.d</code> enthaltenen Skripten sind in Wirklichkeit symbolische Verknüpfungen - bei der Paketinstallierung durch das Programm <code class="command">update-rc.d</code> erstellt, die auf die eigentlichen im Verzeichnis <code class="filename">/etc/init.d/</code> gespeicherten Skripten verweisen. Der Administrator kann die in jedem Runlevel verfügbaren Dienste fein einstellen, indem er den Befehl <code class="command">update-rc.d</code> mit angepassten Parametern erneut ausführt. Die Handbuchseite <span class="citerefentry"><span class="refentrytitle">update-rc.d</span>(1)</span> erläutert die Syntax im Detail. Bitte beachten Sie, dass das Entfernen aller symbolischen Verknüpfungen (mit dem Parameter <code class="literal">remove</code>) kein gutes Verfahren zum Abschalten eines Dienstes ist. Stattdessen sollten Sie ihn einfach so konfigurieren, dass er in dem gewünschten Runlevel nicht startet (und dabei gleichzeitig die entsprechenden Aufrufe zu seinem Abschalten bewahren für den Fall, dass er im vorhergehenden Runlevel läuft). Da <code class="command">update-rc.d</code> eine etwas verschachtelte Schnittstelle hat, benutzen Sie vielleicht lieber <code class="command">rcconf</code> (aus dem Paket <span class="pkg pkg">rcconf</span>), das eine benutzerfreundlichere Schnittstelle bereitstellt.
		</div><a id="idm139785325040768" class="indexterm"></a><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>DEBIAN-RICHTLINIEN</em></span> Dienste neu starten</strong></p></div></div></div><a id="idm139785325038528" class="indexterm"></a><a id="idm139785325037408" class="indexterm"></a><a id="idm139785325035968" class="indexterm"></a><div class="para">
			Die Betreuerskripten für Debian-Pakete starten manchmal bestimmte Dienste neu, um ihre Verfügbarkeit sicherzustellen, oder damit sie bestimmte Optionen berücksichtigen. Der Befehl zur Steuerung eines Dienstes - <code class="command">/etc/init.d/<em class="replaceable"><code>dienst</code></em> <em class="replaceable"><code>vorgang</code></em></code> - berücksichtigt Runlevel nicht, geht (fälschlicherweise) davon aus, dass der Dienst gerade benutzt wird, und kann daher falsche Vorgänge auslösen (einen Dienst starten, der bewusst abgeschaltet worden war, einen Dienst anhalten, der bereits angehalten ist usw.). Deshalb hat Debian das Programm <code class="command">invoke-rc.d</code> eingeführt: dieses Programm muss von Betreuerskripten verwendet werden, um Initialisierungsskripten für Dienste aufzurufen und führt nur die erforderlichen Befehle aus. Man beachte, dass das Suffix <code class="filename">.d</code> hier, im Gegensatz zu seiner sonst üblichen Verwendung, in einem Programmnamen und nicht in einem Verzeichnis benutzt wird.
		</div></div><div class="para">
			Schließlich startet <code class="command">init</code> Steuerprogramme für mehrere virtuelle Konsolen (<code class="command">getty</code>). Es zeigt eine Eingabeaufforderung an, an der es auf einen Benutzernamen wartet, und führt dann <code class="command">login <em class="replaceable"><code>benutzer</code></em></code> aus, um eine Sitzung zu eröffnen.
		</div><a id="idm139785325029216" class="indexterm"></a><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>WÖRTERVERZEICHNIS</em></span> Konsole und Terminal</strong></p></div></div></div><div class="para">
			Die ersten Computer waren gewöhnlich in mehrere, sehr große Teile unterteilt: das Speichergehäuse und die zentrale Verarbeitungseinheit waren von den Peripheriegeräten getrennt, die von den Bedienern zu ihrer Steuerung benutzt wurden. Letztere waren Teil einer separaten Einrichtung, der „Konsole“. Dieser Begriff wurde beibehalten, aber seine Bedeutung hat sich verändert. Er wurde mehr oder weniger zu einem Synonym für „Terminal“, das aus einer Tastatur und einem Bildschirm besteht.
		</div><div class="para">
			Im Verlaufe der Entwicklung der Computer haben Betriebssysteme schließlich mehrere virtuelle Konsolen angeboten, um gleichzeitig mehrere unabhängige Sitzungen zu ermöglichen, selbst wenn es nur eine Tastatur und einen Bildschirm gibt. Die meisten GNU/Linux-Systeme bieten sechs virtuelle Konsolen (im Textmodus) an, die durch die Eingabe der Tastenkombinationen <span class="keycap"><strong>Control</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F1</strong></span> bis <span class="keycap"><strong>Control</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F6</strong></span> zugänglich sind.
		</div><div class="para">
			Im weiteren Sinne können die Begriffe „Konsole“ und „Terminal“ sich auch auf einen Terminal-Emulator in einer grafischen X11-Sitzung beziehen (wie zum Beispiel <code class="command">xterm</code>, <code class="command">gnome-terminal</code> oder <code class="command">konsole</code>).
		</div></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.kernel-installation.html"><strong>Zurück</strong>8.11. Einen Kernel installieren</a></li><li class="up"><a accesskey="u" href="#"><strong>Nach oben</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Zum Anfang</strong></a></li><li class="next"><a accesskey="n" href="sect.remote-login.html"><strong>Weiter</strong>9.2. Anmelden aus der Ferne</a></li></ul></body></html>