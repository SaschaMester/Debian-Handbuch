<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.3. Überwachung: Vorbeugung, Entdeckung, Abschreckung</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 3.1.5" /><meta name="package" content="Debian-debian-handbook-7-de-DE-1.0-1" /><meta name="keywords" content="Firewall, Netzfilter, IDS/NIDS" /><link rel="home" href="index.html" title="Das Debian Administrationshandbuch" /><link rel="up" href="security.html" title="Kapitel 14. Sicherheit" /><link rel="prev" href="sect.firewall-packet-filtering.html" title="14.2. Firewall oder Paketfilter" /><link rel="next" href="sect.selinux.html" title="14.4. Einführung in SELinux" /></head><body><p id="title"><a class="left" href="http://www.debian.org"><img alt="Product Site" src="Common_Content/images//image_left.png" /></a><a class="right" href="http://debian-handbook.info"><img alt="Documentation Site" src="Common_Content/images//image_right.png" /></a></p><ul class="docnav top"><li class="previous"><a accesskey="p" href="sect.firewall-packet-filtering.html"><strong>Zurück</strong></a></li><li class="home">Das Debian Administrationshandbuch</li><li class="next"><a accesskey="n" href="sect.selinux.html"><strong>Weiter</strong></a></li></ul><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns="" id="sect.supervision"></a>14.3. Überwachung: Vorbeugung, Entdeckung, Abschreckung</h2></div></div></div><a id="idm139785308125216" class="indexterm"></a><a id="idm139785308124256" class="indexterm"></a><div class="para">
			Monitoring ist aus mehreren Gründen ein integraler Bestandteil jeder Sicherheitsrichtlinie. Unter anderem deshalb, weil das Ziel der Absicherung gewöhnlich nicht darauf beschränkt ist, die Vertraulichkeit der Daten sicherzustellen, sondern auch vorsieht, dass die Verfügbarkeit der Dienste gewährleistet ist. Es ist daher unerlässlich, zu überprüfen, ob alles wie vorgesehen funktioniert, und rechtzeitig jedes abweichende Verhalten und jede Änderung in der Qualität der erbrachten Leistungen zu erkennen. Monitoring hilft dabei Einbruchsversuche zu entdecken und darauf schnell zu reagieren, bevor sie ernste Folgen haben. Dieser Abschnitt gibt einen Überblick über einige Hilfsprogramme, die zur Überwachung verschiedener Aspekte eines Debian-Systems eingesetzt werden können. Damit vervollständigt er den Abschnitt über das allgemeine System-Monitoring in <a class="xref" href="advanced-administration.html">Kapitel 12, <em>Erweiterte Verwaltung</em></a>.
		</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.logcheck"></a>14.3.1. Protokolle mit <code class="command">logcheck</code> verfolgen</h3></div></div></div><a id="idm139785308119904" class="indexterm"></a><a id="idm139785308118784" class="indexterm"></a><a id="idm139785308117344" class="indexterm"></a><div class="para">
				Das Programm <code class="command">logcheck</code> überwacht Protokolldateien standardmäßig jede Stunde. Es schickt E-Mails mit ungewöhnlichen Protokollmeldungen zur weiteren Analyse an den Administrator.
			</div><div class="para">
				Die Liste der überwachten Dateien wird in <code class="filename">/etc/logcheck/logcheck.logfiles</code> gespeichert; die Standardeinstellungen eignen sich gut, solange die Datei <code class="filename">/etc/syslog.conf</code> nicht vollständig verändert worden ist.
			</div><div class="para">
				<code class="command">logcheck</code> kann in drei mehr oder weniger detaillierten Modi laufen: <span class="emphasis"><em>Paranoid</em></span>, <span class="emphasis"><em>Server</em></span> und <span class="emphasis"><em>Arbeitsplatzrechner</em></span>. Der erste ist <span class="emphasis"><em>sehr</em></span> ausführlich und sollte wohl eher auf besondere Server, wie zum Beispiel Firewalls, beschränkt bleiben. Der zweite (voreingestellte) Modus wird für die meisten Server empfohlen. Der letzte ist für Arbeitsplatzrechner bestimmt und ist noch knapper (er unterdrückt mehr Meldungen).
			</div><div class="para">
				In allen drei Fällen sollte <code class="command">logcheck</code> wohl so angepasst werden, dass es einige zusätzliche Meldungen ausschließt (in Abhängigkeit von den installierten Diensten), es sei denn, dass der Administrator tatsächlich jede Stunde stapelweise lange uninteressante E-Mails empfangen möchte. Da das Verfahren zur Auswahl der Meldungen recht kompliziert ist, ist es notwendig - wenn auch schwierig - die Datei <code class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> durchzulesen.
			</div><div class="para">
				Die eingesetzten Regeln können in mehrere Arten unterteilt werden:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						solche, die eine Meldung als einen Einbruchsversuch einstufen (in einer Datei im Verzeichnis <code class="filename">/etc/logcheck/cracking.d/</code> gespeichert);
					</div></li><li class="listitem"><div class="para">
						solche, die eine derartige Einstufung aufheben (<code class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li class="listitem"><div class="para">
						solche, die eine Meldung als Sicherheitswarnung einordnen (<code class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li class="listitem"><div class="para">
						solche, die diese Einordnung aufheben (<code class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li class="listitem"><div class="para">
						und schließlich solche, die auf die übrigen Meldungen zutreffen (als sogenannte <span class="emphasis"><em>Systemvorfälle</em></span> angesehen werden).
					</div></li></ul></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>VORSICHT</em></span> Eine Meldung ignorieren</strong></p></div></div></div><div class="para">
				Eine Meldung, die als Einbruchsversuch oder als Sicherheitswarnung markiert worden ist (aufgrund einer Regel, die in einer Datei namens <code class="filename">/etc/logcheck/violations.d/meine_datei</code> gespeichert ist), kann nur mit einer Regel in den Dateien <code class="filename">/etc/logcheck/violations.ignore.d/meine_datei</code> oder <code class="filename">/etc/logcheck/violations.ignore.d/meine_datei-<em class="replaceable"><code>erweiterung</code></em></code> ignoriert werden.
			</div></div><div class="para">
				Ein Systemvorfall wird immer angezeigt, es sei denn, eine Regel in einem der Verzeichnisse des Typs <code class="filename">/etc/logcheck/ignore.d.{paranoid,server,arbeitsplatzrechner}/</code> bestimmt, dass der Vorfall ignoriert werden soll. Es werden natürlich nur die Verzeichnisse berücksichtigt, deren Ausführlichkeitsgrad gleich dem oder höher als der ausgewählte Betriebsmodus ist.
			</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>TIPP</em></span> Ihre Protokolle als Bildschirmhintergrund</strong></p></div></div></div><div class="para">
				Einige Administratoren möchten ihre Protokollmeldungen gerne in Echtzeit durchlaufen sehen; der Befehl <code class="command">root-tail</code> (im Paket <span class="pkg pkg">root-tail</span>) kann dazu verwendet werden, die Protokolle in den Hintergrund der grafischen Arbeitsfläche zu integrieren. Das Programm <code class="command">xconsole</code> (im Paket <span class="emphasis"><em>x11-apps</em></span>) kann sie ebenfalls in einem kleinen Fenster durchlaufen lassen. Meldungen werden direkt aus <code class="command">syslogd</code> über die Pipe <code class="filename">/dev/xconsole</code> entnommen.
			</div><a id="idm139785308090912" class="indexterm"></a><a id="idm139785308089792" class="indexterm"></a></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.monitoring-activity"></a>14.3.2. Aktivitäten überwachen</h3></div></div></div><a id="idm139785308087104" class="indexterm"></a><a id="idm139785308085664" class="indexterm"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.real-time-monitoring"></a>14.3.2.1. In Echtzeit</h4></div></div></div><div class="para">
					<code class="command">top</code> ist ein interaktives Hilfsprogramm, das eine Liste der gegenwärtig laufenden Prozesse anzeigt. Die voreingestellte Reihenfolge hängt vom momentanen Umfang der Prozessornutzung ab und kann mithilfe der <span class="keycap"><strong>P</strong></span>-Taste abgerufen werden. Andere Sortierreihenfolgen sind unter anderem nach belegtem Speicher (<span class="keycap"><strong>M</strong></span>-Taste), nach gesamter Prozessorzeit (<span class="keycap"><strong>T</strong></span>-Taste) und nach Prozesskennung (<span class="keycap"><strong>N</strong></span>-Taste). Mit der <span class="keycap"><strong>k</strong></span>-Taste kann ein Prozess abgebrochen werden, indem seine Kennung eingegeben wird. Die <span class="keycap"><strong>r</strong></span>-Taste ermöglicht das <span class="emphasis"><em>renicing</em></span> eines Prozesses, das heißt, die Änderung seiner Priorität.
				</div><a id="idm139785308079344" class="indexterm"></a><div class="para">
					Wenn das System überlastet zu sein scheint, ist <code class="command">top</code> ein großartiges Instrument, um zu sehen, welche Prozesse um die Prozessorzeit konkurrieren oder zu viel Speicher verbrauchen. Insbesondere ist es häufig interessant zu überprüfen, ob die Prozesse, die Ressourcen verbrauchen, den tatsächlichen Diensten entsprechen, die der Rechner bekanntermaßen beherbergt. Ein unbekannter Prozess, der unter dem Benutzernamen www-data läuft, sollte wirklich hervorstechen und kann untersucht werden, da er möglicherweise ein Programm ist, das durch eine Schwachstelle in einer Web-Anwendung auf dem System installiert wurde und ausgeführt wird.
				</div><div class="para">
					<code class="command">top</code> ist ein sehr flexibles Hilfsprogramm, und seine Handbuchseite beschreibt ausführlich, wie seine Anzeige individuell eingerichtet und an persönliche Bedürfnisse und Gewohnheiten angepasst werden kann.
				</div><div class="para">
					Die grafischen Hilfsprogramme <code class="command">gnome-system-monitor</code> und <code class="command">qps</code> sind <code class="command">top</code> ähnlich und bieten etwa die gleichen Leistungsmerkmale.
				</div><a id="idm139785308073632" class="indexterm"></a></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.monitoring-history"></a>14.3.2.2. Verlauf</h4></div></div></div><a id="idm139785308071296" class="indexterm"></a><div class="para">
					Prozessorauslastung, Netzwerkverkehr und freier Plattenplatz sind Informationen, die sich ständig ändern. Es ist häufig nützlich, den Verlauf ihrer Entwicklung festzuhalten, um genau feststellen zu können, wie der Rechner genutzt wird.
				</div><a id="idm139785308069616" class="indexterm"></a><a id="idm139785308068656" class="indexterm"></a><div class="para">
					Für diese Aufgabe gibt es zahlreiche spezialisierte Hilfsprogramme. Die meisten von ihnen können Daten über SNMP (<span class="emphasis"><em>Simple Network Management Protocol</em></span>) einholen, um diese Informationen an einer Stelle zusammenzufassen. Ein weiterer Nutzen besteht darin, dass auf diese Weise Daten von Netzwerkelementen eingeholt werden können, die keine Universalrechner sind, wie spezialisierte Netzwerkrouter oder -schalter.
				</div><div class="para">
					Dieses Buch behandelt Munin ausführlich als Teil von <a class="xref" href="advanced-administration.html">Kapitel 12: „<em>Erweiterte Verwaltung</em>“</a> (siehe <a class="xref" href="sect.monitoring.html#sect.munin">Abschnitt 12.4.1, „Munin einrichten“</a>). Debian stellt ebenfalls ein ähnliches Hilfsprogramm bereit: <span class="pkg pkg">cacti</span>. Sein Einsatz ist etwas komplizierter, da es ausschließlich auf SNMP beruht. Obwohl es eine Web-Schnittstelle hat, benötigt das Verständnis der Konzepte, die für die Konfigurierung verwendet werden, noch einige Anstrengung. Die Lektüre der HTML-Dokumentation (<code class="filename">/usr/share/doc/cacti/html/index.html</code>) ist daher als Voraussetzung anzusehen.
				</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ALTERNATIVE</em></span> <code class="command">mrtg</code></strong></p></div></div></div><a id="idm139785308061888" class="indexterm"></a><div class="para">
					<code class="command">mrtg</code> (in dem Paket ähnlichen Namens) ist ein älteres Hilfsprogramm. Trotz einiger Ecken und Kanten kann es Verlaufsdaten zusammenfassen und als Diagramme anzeigen. Es enthält eine Reihe spezieller Skripte zur Sammlung der am häufigsten überprüften Daten wie Prozessorlast, Netzwerkverkehr, Webseitenzugriffe und so weiter.
				</div><div class="para">
					Die Pakete <span class="pkg pkg">mrtg-contrib</span> und <span class="pkg pkg">mrtgutils</span> enthalten Beispielskripte, die direkt verwendet werden können.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="idm139785308057136"></a>14.3.3. Änderungen erkennen</h3></div></div></div><div class="para">
				Nachdem das System installiert und konfiguriert ist, gibt es, abgesehen von Sicherheitsaktualisierungen, normalerweise keinen Grund, dass Dateien und Verzeichnisse sich weiterentwickeln, Daten ausgenommen. Es ist daher interessant sicherzustellen, dass Dateien sich in der Tat nicht ändern: jede unerwartete Veränderung wäre daher eine Untersuchung wert. Dieser Abschnitt stellt einige Hilfsprogramme vor, die Dateien überwachen und den Administrator warnen können, wenn eine unerwartete Veränderung auftritt (oder einfach derartige Veränderungen auflisten).
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.debsums"></a>14.3.3.1. Pakete auditieren: <code class="command">debsums</code> und seine Grenzen</h4></div></div></div><a id="idm139785308053760" class="indexterm"></a><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>WEITERE SCHRITTE</em></span> Schutz vor vorgelagerten Veränderungen</strong></p></div></div></div><div class="para">
					<code class="command">debsums</code> ist nützlich zur Entdeckung von Änderungen an Dateien, die aus einem Debian-Paket stammen. Jedoch ist es nutzlos, falls das Paket selbst beschädigt ist, weil zum Beispiel der Debian-Spiegelserver kompromittiert wurde. Um sich gegen diese Art von Angriffen zu schützen, ist es erforderlich, APTs Verifikationssystem für digitale Signaturen zu benutzen (siehe <a class="xref" href="sect.package-authentication.html">Abschnitt 6.5, „Die Echtheit eines Paketes prüfen“</a>) und darauf zu achten, nur Pakete zertifizierten Ursprungs zu installieren.
				</div></div><div class="para">
					<code class="command">debsums</code> ist ein interessantes Hilfsprogramm, da es mit ihm möglich ist, herauszufinden, welche der installierten Dateien verändert worden sind (möglicherweise von einem Angreifer). Jedoch sollten diese Informationen mit Vorsicht aufgenommen werden, insbesondere weil nicht alle Debian-Pakete die von diesem Programm benötigten digitalen Fingerabdrücke bereitstellen (sie sind, falls vorhanden, in <code class="filename">/var/lib/dpkg/info/<em class="replaceable"><code>paket</code></em>.md5sums</code> zu finden). <a id="idm139785308047488" class="indexterm"></a> <a id="idm139785308046848" class="indexterm"></a> <a id="idm139785308046208" class="indexterm"></a> <a id="idm139785308045568" class="indexterm"></a> Zur Erinnerung: ein Fingerabdruck ist ein Wert, häufig eine Zahl (wenn auch in hexadezimaler Schreibweise), die eine Art Signatur für den Inhalt der Datei enthält. Diese Signatur wird mit einem Algorithmus berechnet (MD5 und SHA1 sind bekannte Beispiele), der mehr oder weniger garantiert, dass selbst kleinste Veränderungen des Dateiinhalts eine Änderung des Fingerabdrucks bewirken; dies wird als „Lawineneffekt“ bezeichnet. Er ermöglicht es, einen einfachen numerischen Fingerabdruck als Lackmustest zu verwenden, um zu überprüfen, ob der Inhalt einer Datei verändert wurde. Diese Algorithmen sind nicht umkehrbar; mit anderen Worten, bei den meisten von ihnen ermöglicht die Kenntnis eines Fingerabdrucks es nicht, den dazugehörigen Inhalt zu finden. Jüngste mathematische Fortschritte schwächen anscheinend die absolute Gültigkeit dieser Prinzipien, aber ihre Verwendung ist bisher nicht infrage gestellt, da es wohl nach wie vor eine recht schwierige Aufgabe ist, einen anderen Inhalt zu erstellen, der denselben Fingerabdruck ergibt.
				</div><div class="para">
					Außerdem sind die <code class="filename">md5sums</code>-Dateien auf der Festplatte gespeichert; ein sorgfältiger Angreifer wird daher diese Dateien aktualisieren, so dass sie die neuen Kontrollsummen für die unterwanderten Dateien enthalten.
				</div><div class="para">
					Der erste Missstand kann dadurch vermieden werden, dass man <code class="command">debsums</code> anweist, seine Überprüfungen auf ein <code class="filename">.deb</code>-Paket zu gründen, anstatt sich auf die <code class="filename">md5sums</code>-Datei zu verlassen. Hierzu müssen jedoch zunächst die passenden <code class="filename">.deb</code>-Dateien heruntergeladen werden:
				</div><pre class="screen">
<code class="computeroutput"># </code><strong class="userinput"><code>apt-get --reinstall -d install `debsums -l`</code></strong>
<code class="computeroutput">[ ... ]
# </code><strong class="userinput"><code>debsums -p /var/cache/apt/archives -g</code></strong>
</pre><div class="para">
					Es sei auch darauf hingewiesen, dass <code class="command">debsums</code> in seiner Standardkonfiguration automatisch die fehlenden <code class="filename">md5sums</code>-Dateien erstellt, wann immer ein Paket mit APT installiert wird.
				</div><div class="para">
					Das andere Problem kann in ähnlicher Weise vermieden werden: die Überprüfung muss einfach auf einer tadellosen <code class="filename">.deb</code>-Datei beruhen. Da dies voraussetzt, dass man über alle <code class="filename">.deb</code>-Dateien für alle installierten Pakete verfügt und ihrer Unversehrtheit sicher ist, besteht der einfachste Weg darin, sie sich von einem Debian-Spiegelserver zu beschaffen. Dieser Vorgang kann langsam und mühsam sein und sollte daher nicht als eine regelmäßig zu nutzende proaktive Vorgehensweise angesehen werden.
				</div><pre class="screen">
<code class="computeroutput"># </code><strong class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code class="computeroutput">[ ... ]
# </code><strong class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong>
</pre><div class="para">
					Man beachte, dass in diesem Beispiel der Befehl <code class="command">grep-status</code> aus dem Paket <span class="pkg pkg">grep-dctrl</span> verwendet wird, das nicht standardmäßig installiert ist.
				</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="idm139785308030960"></a>14.3.3.2. Dateien überwachen: AIDE</h4></div></div></div><a id="idm139785308030192" class="indexterm"></a><div class="para">
					Das Hilfsprogramm AIDE (<span class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) ermöglicht es, die Unversehrtheit von Dateien zu überprüfen und jede Veränderung durch einen Vergleich mit einem zuvor festgehaltenen Abbild des intakten Systems zu entdecken. Dieses Abbild ist als Datenbank (<code class="filename">/var/lib/aide/aide.db</code>) abgespeichert, die relevante Informationen über alle Dateien des Systems enthält (Fingerabdrücke, Berechtigungen, Zeitstempel und so weiter). Diese Datenbank wird erstmals mit dem Befehl <code class="command">aideinit</code> initialisiert; sie wird dann täglich (mit dem Skript <code class="filename">/etc/cron.daily/aide</code>) genutzt, um nachzuprüfen, dass sich nichts Relevantes verändert hat. Wenn Veränderungen entdeckt werden, hält AIDE diese in Protokolldateien fest (<code class="filename">/var/log/aide/*.log</code>) und sendet seine Befunde per E-Mail an den Administrator.
				</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>IN DER PRAXIS</em></span> Die Datenbank schützen</strong></p></div></div></div><div class="para">
					Da AIDE eine lokale Datenbank nutzt, um den Status der Dateien zu vergleichen, ist die Gültigkeit seiner Ergebnisse direkt an die Gültigkeit der Datenbank gebunden. Falls ein Angreifer auf einem kompromittierten System Administratorrechte erlangt, ist er in der Lage, die Datenbank auszutauschen und so seine Spuren zu verwischen. Eine mögliche Behelfslösung könnte darin bestehen, die Referenzdaten auf einem schreibgeschützten Medium zu speichern.
				</div></div><div class="para">
					Viele Optionen in <code class="filename">/etc/default/aide</code> können dazu verwendet werden, das Verhalten des Pakets <span class="pkg pkg">aide</span> zu justieren. AIDEs eigentliche Konfiguration ist in <code class="filename">/etc/aide/aide.conf</code> und <code class="filename">/etc/aide/aide.conf.d/</code> gespeichert (diese Dateien werden genau genommen nur von <code class="command">update-aide.conf</code> dazu benutzt, die Datei <code class="filename">/var/lib/aide/aide.conf.autogenerated</code> zu erstellen). Die Konfiguration gibt an, welche Eigenschaften welcher Dateien überprüft werden sollen. Der Inhalt von Protokolldateien verändert sich zum Beispiel regelmäßig, und derartige Veränderungen können ignoriert werden, solange die Berechtigungen dieser Dateien die gleichen bleiben. Aber sowohl der Inhalt als auch die Berechtigungen von ausführbaren Dateien müssen unverändert bleiben. Obwohl die Konfigurationssyntax nicht sehr komplex ist, ist sie nicht völlig intuitiv. Daher wird empfohlen, die Handbuchseite <span class="citerefentry"><span class="refentrytitle">aide.conf</span>(5)</span> zu lesen.
				</div><div class="para">
					Eine neue Version der Datenbank wird täglich in <code class="filename">/var/lib/aide/aide.db.new</code> erstellt; falls alle aufgenommenen Veränderungen legitim waren, kann sie als Ersatz für die Referenzdatenbank verwendet werden.
				</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ALTERNATIVE</em></span> Tripwire und Samhain</strong></p></div></div></div><div class="para">
					Tripwire ist AIDE sehr ähnlich; selbst die Syntax der Konfigurationsdatei ist fast die gleiche. Die Hauptergänzung, die von <span class="pkg pkg">tripwire</span> bereitgestellt wird, ist ein Verfahren, die Konfigurationsdatei zu signieren, so dass ein Angreifer mit ihr nicht auf eine andere Version der Referenzdatenbank verweisen kann.
				</div><div class="para">
					Samhain bietet ebenfalls ähnliche Leistungsmerkmale, sowie einige Funktionen, um Rootkits zu entdecken (siehe KURZER BLICK in der Seitenleiste). Es kann auch netzwerkweit eingesetzt werden und seine Spuren (mit einer Signatur) auf einem zentralen Server festhalten.
				</div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>KURZER BLICK</em></span> Die Pakete <span class="pkg pkg">checksecurity</span> und <span class="pkg pkg">chkrootkit</span>/<span class="pkg pkg">rkhunter</span></strong></p></div></div></div><a id="idm139785307491504" class="indexterm"></a><div class="para">
					Das erste dieser Pakete enthält verschiedene kleine Skripte, die grundlegende Prüfungen des Systems durchführen (leere Passwörter, neue setuid-Dateien usw.) und den Administrator, falls nötig, warnen. Allerdings sollte sich trotz seines eindeutigen Namens kein Administrator nur auf dieses Paket verlassen, wenn er dafür sorgen möchte, dass ein Linux-System sicher ist.
				</div><div class="para">
					Die Pakete <span class="pkg pkg">chkrootkit</span> und <span class="pkg pkg">rkhunter</span> ermöglichen es, nach möglicherweise auf dem System installierten <span class="emphasis"><em>Rootkits</em></span> Ausschau zu halten. Zur Erinnerung: dies sind Programme, die dazu bestimmt sind, die Kompromittierung eines Systems zu verbergen und gleichzeitig diskret den Rechner im Griff zu halten. Die Tests sind nicht zu 100% zuverlässig, aber sie können gewöhnlich die Aufmerksamkeit des Administrators auf die möglichen Probleme lenken.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.intrusion-detection"></a>14.3.4. Eindringen entdecken (IDS/NIDS)</h3></div></div></div><a id="idm139785307485264" class="indexterm"></a><a id="idm139785307484304" class="indexterm"></a><a id="idm139785307483344" class="indexterm"></a><a id="idm139785307482384" class="indexterm"></a><a id="idm139785307481424" class="indexterm"></a><a id="idm139785307480464" class="indexterm"></a><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Denial of Service</strong></p></div></div></div><a id="idm139785307477936" class="indexterm"></a><div class="para">
				Ein „Denial-of-Service“-Angriff hat nur ein Ziel: einen Dienst nicht verfügbar zu machen. Ob ein solcher Angriff nun darin besteht, den Server mit Anfragen zu überlasten oder einen Fehler auszunutzen, das Ergebnis ist das gleiche: der Dienst ist nicht mehr funktionsfähig. Die normalen Benutzer sind unzufrieden, und der Ruf der Organisation, die den angegriffenen Netzwerkdienst bereitstellt, erleidet Schaden (und verliert möglicherweise Einnahmen, falls zum Beispiel der Dienst eine E-Commerce-Website war).
			</div><div class="para">
				Solch ein Angriff erfolgt manchmal „verteilt“; dazu gehört es normalerweise, den Server mit einer großen Anzahl von Anfragen, die von vielen verschiedenen Quellen kommen, zu überlasten, so dass der Server nicht mehr imstande ist, die seriösen Anfragen zu beantworten. Diese Art von Angriffen hat bekannte Abkürzungen erhalten: <acronym class="acronym">DoS</acronym> und <acronym class="acronym">DDoS</acronym> (je nachdem, ob der Denial-of-Service-Angriff verteilt ist oder nicht).
			</div></div><div class="para">
				<code class="command">snort</code> (im gleichnamigen Debian-Paket) ist ein NIDS - ein <span class="emphasis"><em>Network Intrusion Detection System</em></span>. Seine Funktion besteht darin, das Netzwerk abzuhören und zu versuchen, Eindringversuche oder feindliche Handlungen (einschließlich eines Denial-of-Service-Angriffs) zu entdecken. Alle diese Vorgänge werden protokolliert und eine tägliche E-Mail mit einer Zusammenfassung der vergangenen 24 Stunden an den Administrator geschickt.
			</div><a id="idm139785307472400" class="indexterm"></a><div class="para">
				Zu seiner Konfigurierung muss der Adressbereich, den das lokale Netzwerk abdeckt, bezeichnet werden. In der Praxis ist dies der Satz aller möglichen Angriffsziele. Andere wichtige Parameter können mit <code class="command">dpkg-reconfigure snort</code> eingestellt werden, einschließlich der zu überwachenden Netzwerk-Schnittstelle. Dies wird häufig <code class="literal">eth0</code> für eine Ethernet-Verbindung sein, aber es gibt auch andere Möglichkeiten, wie <code class="literal">ppp0</code> für ein ADSL, ein PSTN (<span class="emphasis"><em>Public Switched Telephone Network</em></span>) oder das gute alte Einwahlmodem, oder auch <code class="literal">wlan0</code> für kabellose Netzwerkkarten.
			</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>WEITERE SCHRITTE</em></span> Integration mit <code class="command">prelude</code></strong></p></div></div></div><div class="para">
				Prelude ermöglicht eine zentralisierte Überwachung von Sicherheitsinformationen. Seine modulare Architektur enthält einen Server (den <span class="emphasis"><em>Manager</em></span> im Paket <span class="pkg pkg">prelude-manager</span>), der Alarmmeldungen sammelt, die von verschiedenen Arten von <span class="emphasis"><em>Sensoren</em></span> erzeugt werden.
			</div><div class="para">
				Snort kann als ein solcher Sensor konfiguriert werden. Eine andere Möglichkeit ist <span class="emphasis"><em>prelude-lml</em></span> (<span class="emphasis"><em>Log Monitor Lackey</em></span>), das Protokolldateien überwacht (in ähnlicher Weise wie das in <a class="xref" href="sect.supervision.html#sect.logcheck">Abschnitt 14.3.1, „Protokolle mit <code class="command">logcheck</code> verfolgen“</a> beschriebene <code class="command">logcheck</code>).
			</div><a id="idm139785307462224" class="indexterm"></a></div><div class="para">
				Die Konfigurationsdatei von <code class="command">snort</code> (<code class="filename">/etc/snort/snort.conf</code>) ist sehr lang, und die ausgiebigen Kommentare beschreiben jede Anweisung in allen Einzelheiten. Um aus ihr möglichst viel herauszuholen, ist es erforderlich, sie vollständig durchzulesen und sie dann an die lokale Situation anzupassen. Zum Beispiel kann die Angabe darüber, welcher Rechner welchen Dienst beherbergt, die Anzahl der Vorfälle, die <code class="command">snort</code> meldet, einschränken, da ein Denial-of-Service-Angriff auf einen Arbeitsplatzrechner deutlich weniger kritisch ist als auf einen DNS-Server. Eine andere interessante Anweisung ermöglicht es, die Zuordnungen zwische IP-Adressen und MAC-Adressen (diese identifizieren eine Netzwerkkarte eindeutig) zu speichern, um so <span class="emphasis"><em>ARP-spoofing</em></span>-Angriffe zu entdecken, bei denen ein kompromittierter Rechner versucht, sich als ein anderer, wie zum Beispiel einen empfindlichen Server, auszugeben.
			</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>VORSICHT</em></span> Wirkungsbereich</strong></p></div></div></div><div class="para">
				Die Effektivität von <code class="command">snort</code> wird durch den Datenverkehr begrenzt, der an der überwachten Netzwerk-Schnittstelle sichtbar ist. Es kann natürlich nichts entdecken, wenn es den tatsächlichen Datenverkehr nicht beobachten kann. Wenn es an einen Netzwerkschalter angeschlossen ist, wird es daher nur Angriffe überwachen, die auf den Rechner, auf dem es läuft, abzielen, was möglicherweise nicht die Absicht ist. Der Rechner, der <code class="command">snort</code> beherbergt, sollte daher an den „Spiegel“-Port des Schalters angeschlossen werden, der normalerweise speziell dafür vorgesehen ist, Schalter zu verketten und daher allen Datenverkehr erhält.
			</div><div class="para">
				In einem kleinen Netzwerk, das sich auf einen Netzwerk-Hub stützt, besteht dieses Problem nicht, da alle Rechner allen Datenverkehr erhalten.
			</div></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sect.firewall-packet-filtering.html"><strong>Zurück</strong>14.2. Firewall oder Paketfilter</a></li><li class="up"><a accesskey="u" href="#"><strong>Nach oben</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Zum Anfang</strong></a></li><li class="next"><a accesskey="n" href="sect.selinux.html"><strong>Weiter</strong>14.4. Einführung in SELinux</a></li></ul></body></html>