<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.2. Anmelden aus der Ferne</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 3.1.5" /><meta name="package" content="Debian-debian-handbook-7-de-DE-1.0-1" /><meta name="keywords" content="Systemstart, Initialisierungsskripten, SSH, Telnet, Rechte, Berechtigungen, Überwachung, Inetd, Cron, Datensicherung, Wechsel im laufenden Betrieb, PCMCIA, APM, ACPI" /><link rel="home" href="index.html" title="Das Debian Administrationshandbuch" /><link rel="up" href="unix-services.html" title="Kapitel 9. Unix-Dienste" /><link rel="prev" href="unix-services.html" title="Kapitel 9. Unix-Dienste" /><link rel="next" href="sect.rights-management.html" title="9.3. Berechtigungen verwalten" /></head><body><p id="title"><a class="left" href="http://www.debian.org"><img alt="Product Site" src="Common_Content/images//image_left.png" /></a><a class="right" href="http://debian-handbook.info"><img alt="Documentation Site" src="Common_Content/images//image_right.png" /></a></p><ul class="docnav top"><li class="previous"><a accesskey="p" href="unix-services.html"><strong>Zurück</strong></a></li><li class="home">Das Debian Administrationshandbuch</li><li class="next"><a accesskey="n" href="sect.rights-management.html"><strong>Weiter</strong></a></li></ul><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns="" id="sect.remote-login"></a>9.2. Anmelden aus der Ferne</h2></div></div></div><div class="para">
			Es ist für einen Administrator wichtig, sich aus der Ferne mit einem Rechner verbinden zu können. Server, die in ihrem eigenen Raum eingeschlossen sind, sind selten dauerhaft mit Tastaturen und Bildschirmen ausgestattet - aber sie sind mit dem Netzwerk verbunden.
		</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Client, Server</strong></p></div></div></div><a id="idm139785325015664" class="indexterm"></a><a id="idm139785325014256" class="indexterm"></a><div class="para">
			Ein System, bei dem mehrere Prozesse miteinander kommunizieren. wird häufig mit dem bildlichen Ausdruck „Client-Server“ beschrieben. Der Server ist das Programm, das Anfragen vom Client entgegen nimmt und ausführt. Der Client steuert die Vorgänge, der Server tut nichts aus eigener Initiative.
		</div></div><a id="idm139785325011920" class="indexterm"></a><a id="idm139785325010480" class="indexterm"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.ssh"></a>9.2.1. Sicheres Anmelden aus der Ferne: SSH</h3></div></div></div><a id="idm139785325008496" class="indexterm"></a><a id="idm139785325007536" class="indexterm"></a><div class="para">
				Das <span class="emphasis"><em>SSH</em></span>-Protokoll (Secure SHell) wurden Sicherheit und Zuverlässigkeit bereits im Entwurf berücksichtigt. Verbindungen auf der Basis von SSH sind sicher: der Partner ist authentifiziert und jeglicher Datenverkehr erfolgt verschlüsselt.
			</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>KULTUR</em></span> Telnet und RSH sind veraltet</strong></p></div></div></div><a id="idm139785325004304" class="indexterm"></a><a id="idm139785325003184" class="indexterm"></a><div class="para">
				Vor SSH waren <span class="emphasis"><em>Telnet</em></span> und <span class="emphasis"><em>RSH</em></span> die wesentlichen Werkzeuge um sich aus der Ferne einzuloggen. Heute sind sie weitestgehend überflüssig und sollten nicht weiter benutzt werden, auch wenn Debian sie immer noch zur Verfügung stellt.
			</div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>WÖRTERVERZEICHNIS</em></span> Authentifizierung, Verschlüsselung</strong></p></div></div></div><div class="para">
				Wenn Sie einem Client die Fähigkeit geben müssen, auf einem Server Aktionen auszuführen oder auszulösen, ist Sicherheit wichtig. Sie müssen die Identität des Clients sicherstellen; dies heißt Authentifizierung. Die Identität besteht normalerweise aus einem Passwort, das geheimzuhalten ist, da es sonst von jedem anderen Client erlangt werden könnte. Dies ist der Zweck von Verschlüsselung, einer Art der Codierung, die es zwei Systemen ermöglicht, vertrauliche Informationen über einen öffentlichen Kanal auszutauschen, ohne dabei für andere lesbar zu sein.
			</div><div class="para">
				Authentifizierung und Verschlüsselung werden häufig zusammen genannt, weil beide oft gleichzeitig benutzt werden, und weil sie gewöhnlich durch ähnliche mathematische Konzepte umgesetzt werden.
			</div></div><div class="para">
				SSH bietet auch zwei Dateiübertragungsdienste an. <code class="command">scp</code> ist ein Befehlszeilenprogramm, das wie <code class="command">cp</code> benutzt werden kann, nur dass jedem Pfad zu einem anderen Rechner der Name dieses Rechners gefolgt von einem Doppelpunkt vorangestellt wird.
			</div><pre class="screen"><code class="computeroutput">$ </code><strong class="userinput"><code>scp datei rechner:/tmp/</code></strong></pre><div class="para">
				<code class="command">sftp</code> ist ein interaktiver Befehl, ähnlich wie <code class="command">ftp</code>. In einer einzigen Sitzung kann <code class="command">sftp</code> mehrere Dateien übertragen, und es ist möglich, mit ihm Dateien auf einem entfernten Rechner zu bearbeiten (löschen, umbenennen, Berechtigungen ändern usw.).
			</div><a id="idm139785324992768" class="indexterm"></a><a id="idm139785324991648" class="indexterm"></a><div class="para">
				Debian verwendet OpenSSH, eine freie Version von SSH, die vom <code class="command">OpenBSD</code>-Projekt betreut wird (einem freien Betriebssystem, das auf dem BSD-Kernel aufbaut und seinen Schwerpunkt auf Sicherheit setzt), und eine Abspaltung der ursprünglich vom finnischen Unternehmen SSH Communications Security Corp. entwickelten SSH-Software. Dieses Unternehmen entwickelte SSH ursprünglich als freie Software, entschied sich jedoch schließlich, seine Entwicklung unter einer proprietären Lizenz fortzusetzen. Das OpenBSD-Projekt schuf daraufhin OpenSSH, um eine freie Version von SSH zu bewahren.
			</div><a id="idm139785324989024" class="indexterm"></a><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> <span class="foreignphrase"><em class="foreignphrase">Abspaltung</em></span></strong></p></div></div></div><a id="idm139785325344976" class="indexterm"></a><div class="para">
				Eine „Abspaltung“ im Softwarebereich ist ein neues Vorhaben, das als Klon eines bestehenden Vorhabens beginnt und mit ihm konkurriert. Von da an entwickeln sich beide Programme, was neue Entwicklungen angeht, gewöhnlich schnell auseinander. Eine Abspaltung ist häufig die Folge von Meinungsverschiedenheiten innerhalb des Entwicklungsteams.
			</div><div class="para">
				Die Option, ein Vorhaben abzuspalten, ist eine direkte Folge der Eigenart freier Software; eine Abspaltung ist ein heilsamer Vorgang, wenn sie die Fortführung eines Vorhabens als freie Software ermöglicht (zum Beispiel im Falle von Lizenzänderungen). Dagegen ist eine Abspaltung, die sich aus technischen oder persönlichen Meinungsverschiedenheiten ergibt, häufig eine Verschwendung menschlicher Ressourcen; eine andere Lösung wäre vorzuziehen. Auch der Zusammenschluss zweier Vorhaben, die früher durch eine Abspaltung gegangen sind, ist nicht gänzlich unbekannt.
			</div></div><div class="para">
				OpenSSH ist in zwei Pakete aufgeteilt: der Client-Teil befindet sich im Paket <span class="pkg pkg">openssh-client</span> und der Server-Teil im Paket <span class="pkg pkg">openssh-server</span>. Das Metapaket <span class="pkg pkg">ssh</span> ist von beiden Teilen abhängig und erleichtert die Installation beider (<code class="command">apt-get install ssh</code>).
			</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.ssh-key-based-auth"></a>9.2.1.1. Schlüsselbasierte Authentifizierung</h4></div></div></div><div class="para">
					Jedes Mal, wenn sich jemand über SSH anmeldet, fragt der entfernte Server nach einem Passwort zur Authentifizierung des Benutzers. Dies kann problematisch sein, wenn man eine Verbindung automatisieren möchte, oder wenn man ein Hilfsprogramm verwendet, das häufige Verbindungen über SSH benötigt. Daher bietet SSH ein schlüsselbasiertes Authentifizierungssystem.
				</div><div class="para">
					Der Benutzer erzeugt auf dem Client-Rechner mit dem Befehl <code class="command">ssh-keygen -t rsa</code> ein neues Schlüsselpaar; der öffentliche Schlüssel wird in der Datei <code class="filename">~/.ssh/id_rsa.pub</code> gespeichert und der dazugehörige private Schlüssel in <code class="filename">~/.ssh/id_rsa</code>. Der Benutzer verwendet dann den Befehl <code class="command">ssh-copy-id <em class="replaceable"><code>server</code></em></code>, um seinen öffentlichen Schlüssel auf dem Server zur Datei <code class="filename">~/.ssh/authorized_keys</code> hinzuzufügen. Falls der private Schlüssel zur Zeit seiner Erzeugung nicht mit einer „Passphrase“ geschützt wurde, funktionieren alle nachfolgenden Anmeldungen auf dem Server ohne Eingabe eines Passworts. Anderenfalls muss der private Schlüssel jedes Mal erneut unter Eingabe der Passphrase entschlüsselt werden. Glücklicherweise ermöglicht es das Programm <code class="command">ssh-agent</code>, private Schlüssel im Speicher zu halten, so dass das Passwort nicht ständig neu eingegeben werden muss. Hierzu verwendet man einfach (einmal pro Sitzung) den Befehl <code class="command">ssh-add</code>, wobei Voraussetzung ist, dass die Sitzung bereits einer funktionsfähigen Instanz von <code class="command">ssh-agent</code> zugeordnet ist. Debian aktiviert dieses Programm standardmäßig beim Start einer grafischen Sitzung, es kann jedoch durch eine Änderung der Datei <code class="filename">/etc/X11/Xsession.options</code> deaktiviert sein. In einer Konsolensitzung kann es manuell mit dem Befehl <code class="command">eval $(ssh-agent)</code> gestartet werden.
				</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>SICHERHEIT</em></span> Schutz des privaten Schlüssels</strong></p></div></div></div><div class="para">
					Wer immer im Besitz des privaten Schlüssels ist, kann sich auf dem entsprechend konfigurierten Konto anmelden. Daher ist der Zugriff auf den privaten Schlüssel durch eine „Passphrase“ geschützt. Selbst wenn jemand in den Besitz eines privaten Schlüssels gelangt (zum Beispiel die Datei <code class="filename">~/.ssh/id_rsa</code>), muss er zusätzlich noch diese Phrase kennen, um ihn verwenden zu können. Dieser zusätzliche Schutz ist jedoch nicht unüberwindlich, und wenn Sie denken, dass die Sicherheit dieser Datei nicht mehr gewährleistet ist, sollten Sie diesen Schlüssel auf den Rechnern, auf denen er installiert wurde, deaktivieren (indem Sie ihn aus <code class="filename">authorized_keys</code> entfernen) und durch einen neu erzeugten Schlüssel ersetzen.
				</div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>KULTUR</em></span> OpenSSL-Schwachstelle in Debian <span class="distribution distribution">Etch</span></strong></p></div></div></div><div class="para">
					Die OpenSSL-Bibliothek, die ursprünglich mit Debian <span class="distribution distribution">Etch</span> bereitgestellt wurde, hatte ein gravierendes Problem in ihrem Zufallszahlengenerator (RNG). In der Tat hatte der zuständige Debian-Betreuer eine Änderung vorgenommen, damit Anwendungen, die ihn verwenden, keine Warnmeldungen mehr verursachen, wenn sie von Werkzeugen für das Memory Management wie zum Beispiel <code class="command">valgrind</code> analysiert werden. Leider hatte diese Änderung auch zur Folge, dass der Zufallszahlengenerator nur eine Entropie-Quelle in Abhängigkeit von der Prozesskennung (PID) benutzte, deren 32.000 mögliche Werte keinen ausreichenden Grad an Zufälligkeit boten. <div xmlns="" class="url">→ <a xmlns="http://www.w3.org/1999/xhtml" href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div class="para">
					Insbesondere, wenn OpenSSL benutzt wurde, um einen Schlüssel zu erzeugen, wurde dieser immer aus einem Satz einiger hunderttausend Schlüssel erstellt (32.000 multipliziert mit einer kleinen Zahl von Schlüssellängen). Hiervon waren SSH-Schlüssel, SSL-Schlüssel und von zahlreichen Anwendungen, wie zum Beispiel OpenVPN, verwendete X.509-Zertifikate betroffen. Ein Eindringling brauchte nur alle Schlüssel auszuprobieren, um unberechtigten Zugriff zu erlangen. Um die Auswirkung des Problems einzuschränken, wurde der SSH-Daemon dahingehend verändert, dass er zweifelhafte Schlüssel, die in den Paketen <span class="pkg pkg">openssh-blacklist</span> und <span class="pkg pkg">openssh-blacklist-extra</span> aufgelistet sind, zurückweist. Darüber hinaus ermöglicht es der Befehl <code class="command">ssh-vulnkey</code>, möglicherweise gefährdete Schlüssel im System zu identifizieren.
				</div><div class="para">
					Eine eingehendere Analyse dieses Vorfalls zeigt, dass er die Folge mehrerer (kleiner) Probleme ist, sowohl beim OpenSSL-Projekt als auch beim Debian-Paketbetreuer. Eine weitverbreitete Bibliothek wie OpenSSL sollte - unverändert - keine Warnungen erzeugen, wenn sie von <code class="command">valgrind</code> überprüft wird. Außerdem sollte der Code (vor allem so empfindliche Bereiche wie der Zufallszahlengenerator) besser kommentiert sein, um derartige Fehler zu vermeiden. Als der Debian-Betreuer sich seinerseits seine Änderungen von den OpenSSL-Entwicklern bestätigen lassen wollte, hat er seine Änderungen lediglich erläutert, aber nicht den entsprechenden Patch zur Überprüfung vorgelegt. Er hat sich auch nicht deutlich als Betreuer des entsprechenden Debian-Pakets ausgewiesen. Schließlich hat er die Änderungen, die er am ursprünglichen Code vorgenommen hatte, nicht deutlich dokumentiert; alle Änderungen wurden zwar in einem Subversion-Repository abgelegt, dabei aber beim Erstellen des Quellpakets zu einem einzigen Patch zusammengefasst.
				</div><div class="para">
					Es ist unter diesen Umständen schwierig, Korrekturmaßnahmen zu finden, die solche Vorfälle in Zukunft verhindern. Die Lehre, die hieraus gezogen werden kann, ist, dass jede Abweichung, die Debian in Ursprungssoftware einführt, begründet, dokumentiert, möglichst dem Urspungsprojekt vorgelegt und breit veröffentlicht werden muss. Unter diesem Gesichtspunkt wurden das neue Quellpaket-Format („3.0 (quilt)“) und der Debian-Patch-Tracker entwickelt. <div xmlns="" class="url">→ <a xmlns="http://www.w3.org/1999/xhtml" href="http://patch-tracker.debian.org">http://patch-tracker.debian.org</a></div>
				</div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.ssh-x11"></a>9.2.1.2. Entfernte X11-Anwendungen benutzen</h4></div></div></div><div class="para">
					Das SSH-Protokoll ermöglicht die Weiterleitung grafischer Daten („X11“-Sitzung, nach dem Namen des am weitesten verbreiteten grafischen Systems in Unix); der Server stellt hierbei einen besonderen Kanal für diese Daten bereit. Konkret bedeutet dies, dass ein aus der Ferne ausgeführtes, grafisches Programm vom X.org-Server auf dem lokalen Bildschirm dargestellt werden kann, und dass die gesamte Sitzung (Eingabe und Anzeige) abgesichert ist. Da entfernte Anwendungen durch diese Funktion das lokale System beeinträchtigen können, ist sie standardmäßig deaktiviert. Sie kann aktiviert werden, indem man in der Serverkonfigurationsdatei (<code class="filename">/etc/ssh/sshd_config</code>) die Option <code class="literal">X11Forwarding yes</code> einstellt. Schließlich muss der Benutzer diese Funktion anfordern, indem er die Option <code class="literal">-X</code> zur Befehlszeile <code class="command">ssh</code> hinzufügt.
				</div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a xmlns="" id="sect.ssh-port-forwarding"></a>9.2.1.3. Verschlüsselte Tunnel mit Port-Weiterleitung einrichten</h4></div></div></div><a id="idm139785325311248" class="indexterm"></a><div class="para">
					Die Optionen <code class="literal">-R</code> und <code class="literal">-L</code> des Befehls <code class="command">ssh</code> ermöglichen es, „verschlüsselte Tunnel“ zwischen zwei Rechnern zu erstellen, und so einen lokalen TCP-Port (siehe <a class="xref" href="network-infrastructure.html#sidebar.tcp-udp"><span class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> TCP/UDP</a> in der Seitenleiste) sicher an einen entfernten Rechner weiterzuleiten und umgekehrt.
				</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>WÖRTERVERZEICHNIS</em></span> Tunnel</strong></p></div></div></div><a id="idm139785325306656" class="indexterm"></a><a id="idm139785325305216" class="indexterm"></a><div class="para">
					Das Internet und die meisten mit ihm verbundenen LANs arbeiten im Paket-Modus und nicht in einem fest geschalteten Modus. Das heißt, dass ein Paket, das von einem Rechner zu einem anderen verschickt wird, auf dem Weg zu seinem Ziel an mehreren dazwischenliegenden Routern angehalten wird. Dennoch kann man einen fest geschalteten Betrieb nachahmen, indem der Datenstrom in normale IP-Pakete eingeschlossen wird. Diese Pakete laufen über ihren üblichen Weg, jedoch wird der Datenstrom am Ziel dann unverändert rekonstruiert. Man nennt dies einen „Tunnel“ in Analogie zu einem Straßentunnel, bei dem Fahrzeuge direkt vom Eingang (Eingabe) zum Ausgang (Ausgabe) fahren, ohne auf irgendwelche Kreuzungen zu stoßen, im Gegensatz zu einem Weg an der Oberfläche, bei dem es Kreuzungen und Richtungswechsel gibt.
				</div><div class="para">
					Man kann bei dieser Gelegenheit den Tunnel verschlüsseln: der Datenstrom, der durch ihn hindurchläuft, ist dann von außen unkenntlich, wird aber am Tunnelausgang wieder in eine unverschlüsselte Form zurückgeführt.
				</div></div><div class="para">
					<code class="command">ssh -L 8000:server:25 intermediary</code> eröffnet eine SSH-Sitzung mit dem Host <em class="replaceable"><code>intermediary</code></em> und nimmt am lokalen Port 8000 Verbindungen an (siehe <a class="xref" href="sect.remote-login.html#figure.ssh-L">Abbildung 9.2, „Einen lokalen Port mit SSH weiterleiten“</a>). Für jede Verbindung, die an diesem Port hergestellt wird, baut <code class="command">ssh</code> eine Verbindung vom Rechner <em class="replaceable"><code>intermediary</code></em> zum Port 25 des <em class="replaceable"><code>server</code></em> auf und verknüpft beide Verbindungen.
				</div><div class="para">
					<code class="command">ssh -R 8000:server:25 intermediary</code> eröffnet auch eine SSH-Sitzung zum Rechner <em class="replaceable"><code>intermediary</code></em>, aber <code class="command">ssh</code> nimmt dann auf diesem Rechner an Port 8000 Verbindungen an (siehe <a class="xref" href="sect.remote-login.html#figure.ssh-R">Abbildung 9.3, „Einen entfernten Port mit SSH weiterleiten“</a>). Jede Verbindung, die an diesem Port hergestellt wird, veranlasst <code class="command">ssh</code>, eine Verbindung vom lokalen Rechner zum Port 25 des <em class="replaceable"><code>server</code></em> zu öffnen und beide Verbindungen miteinander zu verknüpfen.
				</div><div class="para">
					In beiden Fällen werden Verbindungen zu Port 25 auf dem Host <em class="replaceable"><code>server</code></em> hergestellt, die durch den SSH-Tunnel laufen, der zwischen dem lokalen Rechner und dem Rechner <em class="replaceable"><code>intermediary</code></em> hergestellt wurde. Im ersten Fall ist der Eingang zum Tunnel der lokale Port 8000, und die Daten laufen zum Rechner <em class="replaceable"><code>intermediary</code></em>, bevor sie zum <em class="replaceable"><code>server</code></em> im „öffentlichen“ Netzwerk geleitet werden. Im zweiten Fall sind Ein- und Ausgang im Tunnel vertauscht: der Eingang ist Port 8000 auf dem Rechner <em class="replaceable"><code>intermediary</code></em>, der Ausgang ist auf dem lokalen Host, und die Daten werden dann zum <em class="replaceable"><code>server</code></em> geleitet. In der Praxis ist der Server normalerweise entweder der lokale Rechner oder der intermediäre. Auf diese Weise sichert SSH die Verbindung von einem Ende zum anderen.
				</div><div class="figure"><a xmlns="" id="figure.ssh-L"></a><div class="figure-contents"><div class="mediaobject"><img src="images/ssh-L.png" alt="Einen lokalen Port mit SSH weiterleiten" /></div></div><p class="title"><strong>Abbildung 9.2. Einen lokalen Port mit SSH weiterleiten</strong></p></div><br class="figure-break" /><div class="figure"><a xmlns="" id="figure.ssh-R"></a><div class="figure-contents"><div class="mediaobject"><img src="images/ssh-R.png" alt="Einen entfernten Port mit SSH weiterleiten" /></div></div><p class="title"><strong>Abbildung 9.3. Einen entfernten Port mit SSH weiterleiten</strong></p></div><br class="figure-break" /></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns="" id="sect.remote-desktops"></a>9.2.2. Entfernte grafische Arbeitsflächen benutzen</h3></div></div></div><div class="para">
				VNC (Virtual Network Computing) ermöglicht aus der Ferne Zugriff auf grafische Arbeitsflächen.
			</div><a id="idm139785325283088" class="indexterm"></a><a id="idm139785325282128" class="indexterm"></a><a id="idm139785325281200" class="indexterm"></a><a id="idm139785325279792" class="indexterm"></a><a id="idm139785325278864" class="indexterm"></a><div class="para">
				Dieses Hilfsprogramm wird vor allem zur technischen Unterstützung eingesetzt; der Administrator kann die Fehler sehen, denen ein Benutzer gegenübersteht, und ihm die richtige Vorgehensweise zeigen, ohne vor Ort sein zu müssen.
			</div><a id="idm139785325277232" class="indexterm"></a><a id="idm139785325275920" class="indexterm"></a><a id="idm139785325274608" class="indexterm"></a><div class="para">
				Zunächst muss der Benutzer den Zugriff auf seine Sitzung erlauben. Die grafischen Arbeitsumgebungen GNOME und KDE enthalten <code class="command">vino</code> beziehungsweise <code class="command">krfb</code>, die eine grafische Schnittstelle bereitstellen, über die der Zugriff auf eine bestehende Sitzung mittels VNC möglich ist (beide werden bezeichnet als <span class="emphasis"><em>Entfernter Bildschirm</em></span> sowohl in der Anwendungsübersicht von GNOME als auch im KDE Menü). Bei anderen grafischen Arbeitsumgebungen dient der Befehl <code class="command">x11vnc</code> (aus dem gleichnamigen Debian-Paket) diesem Zweck; man kann ihn für den Benutzer über ein besonderes Icon verfügbar machen.
			</div><a id="idm139785325270416" class="indexterm"></a><a id="idm139785325269104" class="indexterm"></a><a id="idm139785325267792" class="indexterm"></a><a id="idm139785325266480" class="indexterm"></a><div class="para">
				Wenn die grafische Sitzung durch VNC freigeschaltet wurde, muss sich der Administrator über einen VNC-Client mit ihr verbinden. GNOME verfügt zu diesem Zweck über <code class="command">vinagre</code> und <code class="command">remmina</code>, während KDE <code class="command">krdc</code> enthält (im Menü unter <span class="guimenu"><strong>K-Menü</strong></span> → <span class="guisubmenu"><strong>Internet</strong></span> → <span class="guimenuitem"><strong>Krdc - Verbindung zu Fremdrechner</strong></span>). Es gibt weitere VNC-Clients, die die Befehlszeile verwenden, wie zum Beispiel <code class="command">xvnc4viewer</code> im gleichnamigen Debian-Paket. Sobald die Verbindung hergestellt ist, kann der Administrator sehen, was vorgeht, kann aus der Ferne auf dem Rechner arbeiten und dem Benutzer zeigen, wie er vorgehen soll.
			</div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>SICHERHEIT</em></span> VNC über SSH</strong></p></div></div></div><a id="idm139785325259632" class="indexterm"></a><div class="para">
				Falls Sie über VNC eine Verbindung herstellen, Ihre Daten aber nicht im Klartext über das Netzwerk schicken wollen, können Sie sie in einem SSH-Tunnel verbergen (siehe <a class="xref" href="sect.remote-login.html#sect.ssh-port-forwarding">Abschnitt 9.2.1.3, „Verschlüsselte Tunnel mit Port-Weiterleitung einrichten“</a>). Sie müssen nur wissen, dass VNC standardmäßig den Port 5900 für den ersten Bildschirm („localhost:0“ genannt), 5901 für den zweiten („localhost:1“ genannt) usw. verwendet.
			</div><div class="para">
				Der Befehl <code class="command">ssh -L localhost:5901:localhost:5900 -N -T <em class="replaceable"><code>rechner</code></em></code> erstellt einen Tunnel zwischen dem lokalen Port 5901 in der localhost-Schnittstelle und Port 5900 auf dem Host <em class="replaceable"><code>rechner</code></em>. Das erste „localhost“ beschränkt SSH darauf, nur an dieser Schnittstelle des lokalen Rechners auf Anfragen zu warten. Das zweite „localhost“ bezeichnet die Schnittstelle des entfernten Rechners, die den Netzverkehr entgegennehmen wird, der in „localhost:5901“ eintritt. Auf diese Weise verbindet <code class="command">vncviewer localhost:1</code> den VNC-Client mit dem entfernten Bildschirm, obwohl Sie den Namen des lokalen Rechners angeben.
			</div><div class="para">
				Wenn die VNC-Sitzung beendet ist, vergessen Sie nicht, den Tunnel zu schließen, indem Sie auch die entsprechende SSH-Sitzung beenden.
			</div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong><span class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Display Manager</strong></p></div></div></div><a id="idm139785325252480" class="indexterm"></a><a id="idm139785325251360" class="indexterm"></a><a id="idm139785325250240" class="indexterm"></a><a id="idm139785325249120" class="indexterm"></a><a id="idm139785325248000" class="indexterm"></a><a id="idm139785325246560" class="indexterm"></a><div class="para">
				<code class="command">gdm</code>, <code class="command">kdm</code>, <code class="command">lightdm</code> und <code class="command">xdm</code> sind Display Manager. Sie übernehmen kurz nach dem Hochfahren die Kontrolle über die grafische Schnittstelle, um dem Benutzer einen Anmeldebildschirm bereitzustellen. Sobald der Benutzer sich angemeldet hat, führen sie die zum Starten einer grafischen Arbeitssitzung erforderlichen Programme aus.
			</div></div><div class="para">
				VNC funktioniert auch für mobile Anwender oder für Angestellte, die sich gelegentlich von zu Hause aus anmelden müssen, um auf einen entfernten Bildschirm ähnlich dem an ihrem Arbeitsplatz zuzugreifen. Die Konfiguration eines derartigen Dienstes ist komplizierter: zunächst installieren Sie das Paket <span class="pkg pkg">vnc4server</span>, passen die Konfiguration des Display Managers dahingehend an, dass er Anfragen an <code class="literal">XDMCP Query</code> annimmt (für <code class="command">gdm3</code> kann dies durch Hinzufügen von <code class="literal">Enable=true</code> im Abschnitt “xdmcp” von <code class="filename">/etc/gdm3/daemon.conf</code>) und starten schließlich den VNC-Server mit <code class="command">inetd</code>, so dass eine Sitzung automatisch beginnt, wenn ein Benutzer sich anzumelden versucht. Sie können zum Beispiel folgende Zeile zu <code class="filename">/etc/inetd.conf</code> hinzufügen:
			</div><pre class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none
</pre><div class="para">
				Das Umleiten ankommender Verbindungen zum Display Manager löst das Problem der Legitimierung, weil nur Benutzer mit einem lokalen Konto den Anmeldeschirm von <code class="command">gdm</code> passieren können (oder in gleicher Weise <code class="command">kdm</code>, <code class="command">xdm</code> usw.). Da dieses Verfahren problemlos mehrere gleichzeitige Anmeldungen ermöglicht (vorausgesetzt, dass der Server ausreichend leistungsfähig ist), kann es sogar dazu verwendet werden, vollständige Arbeitsflächen für mobile Benutzer bereitzustellen (oder für weniger leistungsstarke Arbeitsplatzrechner, die als Thin Clients konfiguriert sind). Benutzer melden sich einfach mit <code class="command">vncviewer <em class="replaceable"><code>server</code></em>:50</code> beim Bildschirm des Servers an, da der verwendete Port 5950 ist.
			</div><a id="idm139785325234432" class="indexterm"></a></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="unix-services.html"><strong>Zurück</strong>Kapitel 9. Unix-Dienste</a></li><li class="up"><a accesskey="u" href="#"><strong>Nach oben</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Zum Anfang</strong></a></li><li class="next"><a accesskey="n" href="sect.rights-management.html"><strong>Weiter</strong>9.3. Berechtigungen verwalten</a></li></ul></body></html>